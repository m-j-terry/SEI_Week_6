<!DOCTYPE html>
<html lang="en">
  <head>
    <p style="font-weight: bold; font-size: 1.75em;">Written Homework Submission for Sir Michael Terry on the twenty-ninth of April in the 2023rd year of the Common Era, according to the Gregorain calendar</p>
  </head>
  <body>
    <ol>
      <li>In your own words, explain the functionality of Barbie's Wardrobe.</li>
      <ol style="list-style-type: lower-alpha; list-style-type: none; text-indent: 1em; margin-left: -2em; padding-bottom: 0;">
       <li class = answer>Barbie's Wardrobe is a browser game with mostly static properties: set buttons for actions, and an ever-expanding list of Barbie's assets as well as a counter for Barbie's wallet, which updates each time she makes and spends money. The game is built according to the principles of object oriented programming: a Barbie object contains certain key-value pairs, which contribute to the game's functionality. The income value is set to a random integer within a predetermined range. Each time the get paid button is pressed, the wallet updates by adding her income (and the value additional income from any of her properties, which is added into her income). </br>The buy buttons are set according to a basic (real-world!) logic. If Barbie's wallet is not greater than or equal to the price of the thing she is buying, then an alert comes up telling her to get it together (although, in real life, Barbie would buy the birkin on credit and never pay the credit card off, like most of my friends do). If this isn't the case (barbie's wallet IS greater than or equal to the price of what she is buying), then the price of the item is subtracted from the income and the item is pushed into Barbie's wardrobe or assets accordingly (the wardrobe and assets are stored as arrays within the Barbie object.)</li>
      
      
      <li>In your own words, explain the functionality of Tomagotchi.</li>  
      <ol style="list-style-type: lower-alpha; list-style-type: none; text-indent: 1em; margin-left: -2em; padding-bottom: 0;">
       <li class = answer>The Tomagotchi game opens with a starting screen. This screen 'disappears' when the button below is clicked, triggering an eventListener, which updates the CSS property of the starting screen to pre-determined values that render it invisible and intangible to the viewer. A new 'screen' appears, which cycles through the different backgrounds that a person may choose as the home to raise their Tomagotchi. When one of these is selected, this screen is also toggled by an eventListener to render it invisible and intangible, and the background of the screen is updated to reflect the desired background</br>The basic structure of the game revolves around three counters for hunger, play, and sleep. The counters are set to intervals, which slowly inch the Tomagotchi toward programmed death. But good news! There are buttons for feeding, playing, and napping, which allow the (hopefully benevolent) user to counteract the effects of entropy and death! If the player clicks one of these buttons, they can update the Tomagotchi's counter and sustain their lives (all while their own lives are slipping through their own fingertips at an imperceptible rate.) The Tomagotchi also has an age counter, which is updated at a setInterval. When the Tomagotchi reaches certain predetermined levels in maturity, the appearance is updated to display a new image. </li> </ol>
      
      
      <li>In your own words, explain the functionality of Connect Four.</li> 
       <ol style="list-style-type: lower-alpha; list-style-type: none; text-indent: 1em; margin-left: -2em; padding-bottom: 0;">
       <li class = answer>Connect Four is a browser game with dynamic, interactive properties. The game board is designed using html divs, which are styled as circles using CSS border-radius property. Above the board there is a turn-tracker, which updates each time a player takes a turn (by multiplying the turn tracker by -1)--a colors object identifies the purple player and pins as 1 and the orange player/pins as -1. Each time the handle drop event is called (which is each time a player drops a pin!) the getWinner function is called before rendering the gameboard for the next turn. The getWinner function contains four other functions for checking the various directions for a winner. </br>The html gameboard that the players see is manipulated in the DOM using an array of arrays in which each of the arrays represents one of the columns. When a player 'drops a token' into the board, the game starts from the bottom of the column selected and iterates through the array until it reaches the first zero (empty/white space), then updates it according to the current player's color. The gameboard is updated by calling the render function IF the getWinner function does not return a winner. Again, both getWinner() and render() are nested within handleDrop().</li> </ol>
      
    </ol>
  </body>
</html>